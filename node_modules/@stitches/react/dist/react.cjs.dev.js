'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var core = require('@stitches/core');
var React = require('react');

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _iterableToArrayLimit(arr, i) { if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return; var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }

function _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }
var hasWarnedInlineStyle = false;

var createCompoundVariantsMatcher = function createCompoundVariantsMatcher(breakPoints, existingMap) {
  var map = new Map();
  map.set(core.MAIN_BREAKPOINT_ID, _toConsumableArray((existingMap === null || existingMap === void 0 ? void 0 : existingMap.get(core.MAIN_BREAKPOINT_ID)) || []));
  Object.keys(breakPoints).forEach(function (breakpoint) {
    return map.set(breakpoint, _toConsumableArray((existingMap === null || existingMap === void 0 ? void 0 : existingMap.get(breakpoint)) || []));
  });
  return map;
};

var createStyled = function createStyled(config) {
  var css = core.createCss(config);
  var defaultElement = 'div';
  var Box = React.forwardRef(function (props, ref) {
    var Element = props.as || defaultElement;
    return React.createElement(Element, _objectSpread(_objectSpread({
      ref: ref
    }, props), {}, {
      as: undefined
    }));
  });
  var currentAs;
  var configBreakpoints = config.breakpoints || {};

  var styledInstance = function styledInstance() {
    var baseAndVariantStyles = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : function (cssComposer) {
      return cssComposer.compose();
    };
    var Component = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : Box;
    var numberOfCompoundVariants = 0;
    var as = currentAs;

    var _baseAndVariantStyles = baseAndVariantStyles.variants,
        variants = _baseAndVariantStyles === void 0 ? {} : _baseAndVariantStyles,
        base = _objectWithoutProperties(baseAndVariantStyles, ["variants"]);

    var baseStyles = css(base); // compound s vars & constants:
    // keep track of all compound variants:

    var compoundVariants = []; // a map that keeps track of the required number of matching s left for each break point:

    var requiredMatches = createCompoundVariantsMatcher(configBreakpoints); // keep track of the number of available variants

    var evaluatedVariantMap = new Map(); // store pre evaluated variants

    var evaluatedCompoundVariants = new Map(); // tslint:disable-next-line: forin

    for (var Name in variants) {
      var variantMap = new Map(); // tslint:disable-next-line: forin

      for (var ValueName in variants[Name]) {
        var evaluatedStyles = evaluateStylesForAllBreakpoints(variants[Name][ValueName], configBreakpoints, css);
        variantMap.set(ValueName, evaluatedStyles);
      }

      evaluatedVariantMap.set(Name, variantMap);
    }

    var stitchesComponentId = "scid-".concat(core.hashString(JSON.stringify(baseAndVariantStyles)));
    var StitchesComponent = React.forwardRef(function (props, ref) {
      // Check the memoCompsition's identity to warn the user
      // remove in production
      if (process.env.NODE_ENV === 'development') {
        // we're breaking the rules of hooks on purpose as the env will never change
        // eslint-disable-next-line
        var memoStyled = React.useMemo(function () {
          return props.css;
        }, []); // We want this to only eval once

        if (memoStyled !== props.css && !hasWarnedInlineStyle) {
          // tslint:disable-next-line
          console.warn('@stitches/react : The css prop should ideally not be dynamic. Define it outside your component using the css composer, or use a memo hook');
          hasWarnedInlineStyle = true;
        }
      }

      var compositions = [baseStyles];
      var propsWithoutVariantsAndCssProp = {}; // clone the compound s matcher

      var compoundRequiredMatches = createCompoundVariantsMatcher(configBreakpoints, requiredMatches); // keep track of the number of unResolved s so that we could bail early:

      var numberOfUnResolvedCompoundVariants = {
        current: numberOfCompoundVariants
      };

      var _loop = function _loop(_key) {
        // check if the prop is a variant
        if (_key in variants) {
          (function () {
            var evaluatedVariant = evaluatedVariantMap.get(_key); // normalize the value so that we only have to deal with one structure:

            var keyVal = props[_key] && _typeof(props[_key]) !== 'object' ? _defineProperty({}, core.MAIN_BREAKPOINT_ID, props[_key]) : props[_key]; // tslint:disable-next-line: forin

            var _loop2 = function _loop2(breakpoint) {
              // check if the variant exist for this breakpoint
              if (keyVal[breakpoint] && evaluatedVariant && evaluatedVariant.get(String(keyVal[breakpoint]))) {
                var _evaluatedVariant$get;

                compositions.push((_evaluatedVariant$get = evaluatedVariant.get(String(keyVal[breakpoint]))) === null || _evaluatedVariant$get === void 0 ? void 0 : _evaluatedVariant$get[breakpoint]);
              }
              /** Compound variants: */


              if (numberOfUnResolvedCompoundVariants.current) {
                compoundVariants.forEach(function (compoundVariant, i) {
                  // if this breakpoint  matches a compound
                  // eslint-disable-next-line
                  if (String(keyVal[breakpoint]) === String(compoundVariant[_key])) {
                    compoundRequiredMatches.get(breakpoint)[i]--;
                  } // when the required matches reach 0 for any compound ...
                  // we know we have a matched compoundVariant


                  if (compoundRequiredMatches.get(breakpoint)[i] === 0) {
                    var _evaluatedCompoundVar;

                    numberOfUnResolvedCompoundVariants.current--;
                    compositions.push((_evaluatedCompoundVar = evaluatedCompoundVariants.get(compoundVariant)) === null || _evaluatedCompoundVar === void 0 ? void 0 : _evaluatedCompoundVar[breakpoint]);
                  }
                });
              }
              /** End compound variants */

            };

            for (var breakpoint in keyVal) {
              _loop2(breakpoint);
            }
          })();
        } else {
          propsWithoutVariantsAndCssProp[_key] = props[_key];
        }
      };

      for (var _key in props) {
        _loop(_key);
      }

      if (propsWithoutVariantsAndCssProp.css) {
        compositions.push(propsWithoutVariantsAndCssProp.css);
        propsWithoutVariantsAndCssProp.css = undefined;
      }

      return React.createElement(Component, _objectSpread(_objectSpread({}, propsWithoutVariantsAndCssProp), {}, {
        as: props.as || as,
        ref: ref,
        className: css.apply(void 0, [stitchesComponentId].concat(compositions, [props.className]))
      }));
    });
    StitchesComponent.displayName = typeof currentAs === 'string' ? "styled(".concat(currentAs, ")") : Component && Component.displayName ? "styled(".concat(Component.displayName, ")") : "styled(Component)";

    StitchesComponent.toString = function () {
      return ".".concat(stitchesComponentId);
    };

    StitchesComponent.compoundVariant = function (compundVariantsObject, compoundVariantStyles) {
      // Update component level variables:
      numberOfCompoundVariants++; // Each time we add

      compoundVariants.push(compundVariantsObject); // required matches is a map with breakpoints
      // each time we add a compound variant, we also push its length to
      // all of the breakpoints so:
      // requiredMatches.get(breakpoint)[i] === Object.keys(compoundVariants[i]).length
      // at render time we clone the requiredMatches map and whenever a prop matches a compound variant we decrement
      // the required matches for this compound variant at this breakpoint
      // when the required matches hit 0 we know it's a mtach

      requiredMatches.forEach(function (value, key) {
        value.push(Object.keys(compundVariantsObject).length);
      });
      var evaluatedStyles = evaluateStylesForAllBreakpoints(compoundVariantStyles, configBreakpoints, css);
      evaluatedCompoundVariants.set(compundVariantsObject, evaluatedStyles);
      return StitchesComponent;
    };

    return StitchesComponent;
  }; // tslint:disable-next-line


  var styledProxy = new Proxy(function () {}, {
    get: function get(_, prop) {
      if (prop === 'Box') {
        return Box;
      }

      currentAs = String(prop);
      return styledInstance;
    },
    apply: function apply(_, __, _ref2) {
      var _ref3 = _slicedToArray(_ref2, 2),
          Element = _ref3[0],
          styling = _ref3[1];

      if (typeof Element === 'string') {
        currentAs = Element;
        return styledInstance(styling);
      }

      currentAs = undefined;
      return styledInstance(styling, Element);
    }
  });
  return {
    styled: styledProxy,
    css: css
  };
};

function evaluateStylesForAllBreakpoints(styleObject, configBreakpoints, css) {
  var breakpoints = _defineProperty({}, core.MAIN_BREAKPOINT_ID, css(styleObject));

  if (configBreakpoints) {
    // tslint:disable-next-line
    for (var breakpoint in configBreakpoints) {
      breakpoints[breakpoint] = css(_defineProperty({}, breakpoint, styleObject));
    }
  }

  return breakpoints;
}

Object.defineProperty(exports, '_ATOM', {
  enumerable: true,
  get: function () {
    return core._ATOM;
  }
});
exports.createStyled = createStyled;
