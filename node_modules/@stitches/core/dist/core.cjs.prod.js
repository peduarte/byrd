"use strict";

Object.defineProperty(exports, "__esModule", {
  value: !0
});

var currentType, tokenTypes = [ "colors", "space", "fontSizes", "fonts", "fontWeights", "lineHeights", "letterSpacings", "sizes", "borderWidths", "borderStyles", "radii", "shadows", "zIndices", "transitions" ], isServer = "undefined" == typeof window, ATOM = Symbol("ATOM"), unitlessKeys = {
  animationDuration: 1,
  animationIterationCount: 1,
  borderImageOutset: 1,
  borderImageSlice: 1,
  borderImageWidth: 1,
  boxFlex: 1,
  boxFlexGroup: 1,
  boxOrdinalGroup: 1,
  columnCount: 1,
  columns: 1,
  flex: 1,
  flexGrow: 1,
  flexPositive: 1,
  flexShrink: 1,
  flexNegative: 1,
  flexOrder: 1,
  gridRow: 1,
  gridRowEnd: 1,
  gridRowSpan: 1,
  gridRowStart: 1,
  gridColumn: 1,
  gridColumnEnd: 1,
  gridColumnSpan: 1,
  gridColumnStart: 1,
  msGridRow: 1,
  msGridRowSpan: 1,
  msGridColumn: 1,
  msGridColumnSpan: 1,
  fontWeight: 1,
  lineHeight: 1,
  opacity: 1,
  order: 1,
  orphans: 1,
  tabSize: 1,
  widows: 1,
  zIndex: 1,
  zoom: 1,
  WebkitLineClamp: 1,
  fillOpacity: 1,
  floodOpacity: 1,
  stopOpacity: 1,
  strokeDasharray: 1,
  strokeDashoffset: 1,
  strokeMiterlimit: 1,
  strokeOpacity: 1,
  strokeWidth: 1
}, TOKEN_STRING = 1, TOKEN_QUOTED_STRING = 2, TOKEN_FUNCTION = 3, TOKEN_BRACKET = 4, currentToken = "", currentDepth = 0, tokenGroups = [ [] ], tokenizeValue = function(str) {
  if (resetCurrentToken(), tokenGroups = [ [] ], !str) return tokenGroups;
  for (var strLength = str.length, i = 0; i < strLength; i++) {
    var _char = str[i];
    switch (_char) {
     case " ":
      currentType === TOKEN_STRING ? addCurrentTokenToGroup() : currentType && (currentToken += _char);
      break;

     case ",":
      currentDepth ? currentToken += _char : (addCurrentTokenToGroup(), addNewTokenGroup());
      break;

     case '"':
      currentToken += _char, currentDepth || currentType ? 1 === currentDepth && currentType === TOKEN_QUOTED_STRING && (currentDepth = 0, 
      addCurrentTokenToGroup()) : (currentType = TOKEN_QUOTED_STRING, currentDepth = 1);
      break;

     case "(":
      currentDepth || (currentType = TOKEN_FUNCTION), currentDepth++, currentToken += _char;
      break;

     case ")":
      currentToken += _char, currentDepth--, currentType !== TOKEN_FUNCTION || currentDepth || addCurrentTokenToGroup();
      break;

     case "[":
      currentDepth || (currentType = TOKEN_BRACKET), currentToken += _char, currentDepth++;
      break;

     case "]":
      currentToken += _char, --currentDepth || addCurrentTokenToGroup();
      break;

     default:
      currentType || (currentType = TOKEN_STRING), currentToken += _char;
    }
  }
  return currentToken && addCurrentTokenToGroup(), tokenGroups;
};

function resetCurrentToken() {
  currentDepth = currentType = 0, currentToken = "";
}

function addCurrentTokenToGroup() {
  currentType && tokenGroups[tokenGroups.length - 1].push(currentToken), resetCurrentToken();
}

function addNewTokenGroup() {
  tokenGroups[tokenGroups.length] = [], resetCurrentToken();
}

function _slicedToArray(arr, i) {
  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();
}

function _nonIterableRest() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

function _unsupportedIterableToArray(o, minLen) {
  if (o) {
    if ("string" == typeof o) return _arrayLikeToArray(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    return "Object" === n && o.constructor && (n = o.constructor.name), "Map" === n || "Set" === n ? Array.from(o) : "Arguments" === n || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n) ? _arrayLikeToArray(o, minLen) : void 0;
  }
}

function _arrayLikeToArray(arr, len) {
  (null == len || len > arr.length) && (len = arr.length);
  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];
  return arr2;
}

function _iterableToArrayLimit(arr, i) {
  if ("undefined" != typeof Symbol && Symbol.iterator in Object(arr)) {
    var _arr = [], _n = !0, _d = !1, _e = void 0;
    try {
      for (var _s, _i = arr[Symbol.iterator](); !(_n = (_s = _i.next()).done) && (_arr.push(_s.value), 
      !i || _arr.length !== i); _n = !0) ;
    } catch (err) {
      _d = !0, _e = err;
    } finally {
      try {
        _n || null == _i.return || _i.return();
      } finally {
        if (_d) throw _e;
      }
    }
    return _arr;
  }
}

function _arrayWithHoles(arr) {
  if (Array.isArray(arr)) return arr;
}

var unitMatch = /^[0-9.]+[a-z|%]/, easingMatch = /\(.*\)|ease|ease-in|ease-out|ease-in-out|linear|step-start|step-end/, fontSizeMatch = /^([+-]?[0-9.]+([a-z]+|%)?|large(r)?|medium|small(er)?|x{1,3}-large|x{1,2}-small)(\/[+-]?[0-9.]+([a-z]+|%)?)?$/, fontStyleMatch = /^[+-]?[0-9.]+deg$/, fontWeightMatch = /^(0*[1-9][0-9]{0,2}|1000|bold(er)?|lighter)$/, matchString = function(val, regex) {
  return "number" != typeof val && val.match(regex);
}, setChainedValue = function(existingValue, value) {
  var separator = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : ",";
  return existingValue ? "".concat(existingValue).concat(separator).concat(value) : value;
}, emptyTokens = {};

tokenTypes.forEach((function(type) {
  return emptyTokens[type] = {};
}));

var createPropertyParser = function(type) {
  return function(tokens, value) {
    var chains = "number" == typeof value ? [ [ value ] ] : tokenizeValue(value), css = {}, tmpTokens = "number" == typeof value ? emptyTokens : tokens;
    return chains.forEach((function(chain, chainIndex) {
      chain.forEach((function(_value, index) {
        type(tmpTokens, css, _value, index, chain, chainIndex, chains);
      }));
    })), css;
  };
}, background = createPropertyParser((function(tokens, css, value, index, chain, chainIndex, chains) {
  if ("/" !== value) if (matchString(value, /scroll|local|fixed/)) css.backgroundAttachment = setChainedValue(css.backgroundAttachment, value); else if (matchString(value, /^url|linear-gradient|element|image|cross-fade|image-set/)) css.backgroundImage = setChainedValue(css.backgroundImage, value); else if (matchString(value, /border-box|padding-box|content-box|text/)) 1 === chain.filter((function(chainPart) {
    return chainPart.match(/border-box|padding-box|content-box|text/);
  })).length ? (css.backgroundOrigin = setChainedValue(css.backgroundOrigin, value), 
  css.backgroundClip = setChainedValue(css.backgroundClip, value)) : chain.findIndex((function(chainPart) {
    return chainPart.match(/border-box|padding-box|content-box|text/);
  })) === index ? css.backgroundOrigin = setChainedValue(css.backgroundOrigin, value) : css.backgroundClip = setChainedValue(css.backgroundClip, value); else if ("/" === chain[index - 1]) css.backgroundSize = setChainedValue(css.backgroundSize, tokens.sizes[value] || value); else if (matchString(value, /center|top|right|bottom|left/) || matchString(value, unitMatch) || tokens.sizes[value]) css.backgroundPosition = setChainedValue(css.backgroundPosition, tokens.sizes[value] || value); else if (matchString(value, /repeat|no-repeat|repeat-x|repeat-y|space|round/)) css.backgroundRepeat = setChainedValue(css.backgroundRepeat, value); else {
    if (chainIndex !== chains.length - 1) throw new Error("You can only add background colors on the last chain");
    css.backgroundColor = setChainedValue(css.backgroundColor, tokens.colors[value] || value);
  }
})), animation = createPropertyParser((function(_, css, value, index, chain) {
  matchString(value, easingMatch) ? css.animationTimingFunction = setChainedValue(css.animationTimingFunction, value) : matchString(value, /^\d+$|infinite/) ? css.animationIterationCount = setChainedValue(css.animationIterationCount, value) : matchString(value, /normal|reverse|alternate|alternate-reverse/) ? css.animationDirection = setChainedValue(css.animationDirection, value) : matchString(value, /none|forward|backwards|both/) ? css.animationFillMode = setChainedValue(css.animationFillMode, value) : matchString(value, /running|paused/) ? css.animationPlayState = setChainedValue(css.animationPlayState, value) : matchString(value, unitMatch) ? chain.findIndex((function(part) {
    return part.match(unitMatch);
  })) === index ? css.animationDuration = setChainedValue(css.animationDuration, value) : css.animationDelay = setChainedValue(css.animationDelay, value) : css.animationName = setChainedValue(css.animationName, value);
})), font = createPropertyParser((function(tokens, css, value, index, chain, chainIndex, chains) {
  if (chains.shouldParseFontFamily) css.fontFamily = setChainedValue(css.fontFamily, tokens.fonts[value] || value); else {
    var lower = value.toLowerCase();
    switch (!0) {
     case fontStyleMatch.test(lower):
      css.fontStyle += " ".concat(value);
      break;

     case fontWeightMatch.test(lower):
      css.fontWeight = tokens.fontWeights[value] || value;
      break;

     case fontSizeMatch.test(lower):
      chains.shouldParseFontFamily = !0;
      var _value$split2 = _slicedToArray(value.split("/"), 2), fontSize = _value$split2[0], lineHeight = _value$split2[1];
      css.fontSize = tokens.fontSizes[fontSize] || fontSize, lineHeight && (css.lineHeight = tokens.lineHeights[lineHeight] || lineHeight);
      break;

     case "italic" === lower:
     case "oblique" === lower:
      css.fontStyle = value;
      break;

     case "small-caps" === lower:
      css.fontVariant = value;
      break;

     case "condensed" === lower:
     case "expanded" === lower:
     case "extra-condensed" === lower:
     case "extra-expanded" === lower:
     case "semi-condensed" === lower:
     case "semi-expanded" === lower:
     case "ultra-condensed" === lower:
     case "ultra-expanded" === lower:
      css.fontStretch = value;
      break;

     case "caption" === lower:
     case "icon" === lower:
     case "menu" === lower:
     case "message-box" === lower:
     case "small-caption" === lower:
     case "status-bar" === lower:
      chains.shouldParseFontFamily = !0, css.fontFamily = setChainedValue(css.fontFamily, tokens.fonts[value] || value);
    }
  }
})), transition = createPropertyParser((function(_, css, value, index, chain) {
  matchString(value, unitMatch) ? chain.findIndex((function(part) {
    return part.match(unitMatch);
  })) === index ? css.transitionDuration = setChainedValue(css.transitionDuration, value) : css.transitionDelay = setChainedValue(css.transitionDelay, value) : matchString(value, easingMatch) ? css.transitionTimingFunction = setChainedValue(css.transitionTimingFunction, value) : css.transitionProperty = setChainedValue(css.transitionProperty, value);
})), margin = createPropertyParser((function(tokens, css, value, index) {
  0 === index ? (css.marginTop = tokens.space[value] || value, css.marginRight = tokens.space[value] || value, 
  css.marginBottom = tokens.space[value] || value, css.marginLeft = tokens.space[value] || value) : 1 === index ? (css.marginRight = tokens.space[value] || value, 
  css.marginLeft = tokens.space[value] || value) : 2 === index ? css.marginBottom = tokens.space[value] || value : css.marginLeft = tokens.space[value] || value;
})), padding = createPropertyParser((function(tokens, css, value, index) {
  0 === index ? (css.paddingTop = tokens.space[value] || value, css.paddingRight = tokens.space[value] || value, 
  css.paddingBottom = tokens.space[value] || value, css.paddingLeft = tokens.space[value] || value) : 1 === index ? (css.paddingRight = tokens.space[value] || value, 
  css.paddingLeft = tokens.space[value] || value) : 2 === index ? css.paddingBottom = tokens.space[value] || value : css.paddingLeft = tokens.space[value] || value;
})), border = createPropertyParser((function(tokens, css, value) {
  matchString(value, /none|hidden|dotted|dashed|solid|double|groove|ridge|inset|outset/) ? (css.borderTopStyle = value, 
  css.borderRightStyle = value, css.borderBottomStyle = value, css.borderLeftStyle = value) : matchString(value, unitMatch) || tokens.borderWidths[value] || !isNaN(value) ? (css.borderTopWidth = tokens.borderWidths[value] || value, 
  css.borderRightWidth = tokens.borderWidths[value] || value, css.borderBottomWidth = tokens.borderWidths[value] || value, 
  css.borderLeftWidth = tokens.borderWidths[value] || value) : (css.borderTopColor = tokens.colors[value] || value, 
  css.borderRightColor = tokens.colors[value] || value, css.borderBottomColor = tokens.colors[value] || value, 
  css.borderLeftColor = tokens.colors[value] || value);
})), borderTop = createPropertyParser((function(tokens, css, value) {
  matchString(value, /none|hidden|dotted|dashed|solid|double|groove|ridge|inset|outset/) ? css.borderTopStyle = value : matchString(value, unitMatch) || tokens.borderWidths[value] || !isNaN(value) ? css.borderTopWidth = tokens.borderWidths[value] || value : css.borderTopColor = tokens.colors[value] || value;
})), borderRight = createPropertyParser((function(tokens, css, value) {
  matchString(value, /none|hidden|dotted|dashed|solid|double|groove|ridge|inset|outset/) ? css.borderRightStyle = value : matchString(value, unitMatch) || tokens.borderWidths[value] || !isNaN(value) ? css.borderRightWidth = tokens.borderWidths[value] || value : css.borderRightColor = tokens.colors[value] || value;
})), borderLeft = createPropertyParser((function(tokens, css, value) {
  matchString(value, /none|hidden|dotted|dashed|solid|double|groove|ridge|inset|outset/) ? css.borderLeftStyle = value : matchString(value, unitMatch) || tokens.borderWidths[value] || !isNaN(value) ? css.borderLeftWidth = tokens.borderWidths[value] || value : css.borderLeftColor = tokens.colors[value] || value;
})), borderBottom = createPropertyParser((function(tokens, css, value) {
  matchString(value, /none|hidden|dotted|dashed|solid|double|groove|ridge|inset|outset/) ? css.borderBottomStyle = value : matchString(value, unitMatch) || tokens.borderWidths[value] || !isNaN(value) ? css.borderBottomWidth = tokens.borderWidths[value] || value : css.borderBottomColor = tokens.colors[value] || value;
})), borderWidth = createPropertyParser((function(tokens, css, value, index) {
  0 === index ? (css.borderTopWidth = tokens.borderWidths[value] || value, css.borderRightWidth = tokens.borderWidths[value] || value, 
  css.borderBottomWidth = tokens.borderWidths[value] || value, css.borderLeftWidth = tokens.borderWidths[value] || value) : 1 === index ? (css.borderRightWidth = tokens.borderWidths[value] || value, 
  css.borderLeftWidth = tokens.borderWidths[value] || value) : 2 === index ? css.borderBottomWidth = tokens.borderWidths[value] || value : css.borderLeftWidth = tokens.borderWidths[value] || value;
})), borderColor = createPropertyParser((function(tokens, css, value, index) {
  0 === index ? (css.borderTopColor = tokens.colors[value] || value, css.borderRightColor = tokens.colors[value] || value, 
  css.borderBottomColor = tokens.colors[value] || value, css.borderLeftColor = tokens.colors[value] || value) : 1 === index ? (css.borderRightColor = tokens.colors[value] || value, 
  css.borderLeftColor = tokens.colors[value] || value) : 2 === index ? css.borderBottomColor = tokens.colors[value] || value : css.borderLeftColor = tokens.colors[value] || value;
})), borderStyle = createPropertyParser((function(tokens, css, value, index) {
  0 === index ? (css.borderTopStyle = value, css.borderRightStyle = value, css.borderBottomStyle = value, 
  css.borderLeftStyle = value) : 1 === index ? (css.borderRightStyle = value, css.borderLeftStyle = value) : 2 === index ? css.borderBottomStyle = value : css.borderLeftStyle = value;
})), borderRadius = createPropertyParser((function(tokens, css, value, index) {
  0 === index ? (css.borderBottomLeftRadius = tokens.radii[value] || value, css.borderTopLeftRadius = tokens.radii[value] || value, 
  css.borderTopRightRadius = tokens.radii[value] || value, css.borderBottomRightRadius = tokens.radii[value] || value) : 1 === index ? (css.borderTopRightRadius = tokens.radii[value] || value, 
  css.borderBottomLeftRadius = tokens.radii[value] || value) : 2 === index ? css.borderBottomRightRadius = tokens.radii[value] || value : 3 === index && (css.borderBottomLeftRadius = tokens.radii[value] || value);
})), boxShadow = function(tokens, value) {
  return {
    boxShadow: tokenizeValue(value).map((function(chain) {
      return chain.map((function(val) {
        return tokens.colors[val] || val;
      })).join(" ");
    })).join(", ")
  };
}, textDecoration = createPropertyParser((function(tokens, css, value) {
  matchString(value, /unset/) ? (css.textDecorationStyle = value, css.textDecorationLine = value, 
  css.textDecorationColor = value, css.textDecorationThickness = value) : matchString(value, /solid|double|dotted|dashed|wavy/) ? css.textDecorationStyle = value : matchString(value, /none|underline|overline|line-through|blink/) ? css.textDecorationLine = setChainedValue(css.textDecorationLine, value, " ") : matchString(value, unitMatch) || matchString(value, /auto|from-font/) ? css.textDecorationThickness = value : css.textDecorationColor = tokens.colors[value] || value;
}));

function ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter((function(sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    }))), keys.push.apply(keys, symbols);
  }
  return keys;
}

function _objectSpread(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = null != arguments[i] ? arguments[i] : {};
    i % 2 ? ownKeys(Object(source), !0).forEach((function(key) {
      _defineProperty(target, key, source[key]);
    })) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach((function(key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    }));
  }
  return target;
}

function _defineProperty(obj, key, value) {
  return key in obj ? Object.defineProperty(obj, key, {
    value: value,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : obj[key] = value, obj;
}

var MAIN_BREAKPOINT_ID = "initial", cssPropToToken = {
  gap: "space",
  gridGap: "space",
  columnGap: "space",
  gridColumnGap: "space",
  rowGap: "space",
  gridRowGap: "space",
  inset: "space",
  insetBlock: "space",
  insetBlockEnd: "space",
  insetBlockStart: "space",
  insetInline: "space",
  insetInlineEnd: "space",
  insetInlineStart: "space",
  margin: "space",
  marginTop: "space",
  marginRight: "space",
  marginBottom: "space",
  marginLeft: "space",
  marginBlock: "space",
  marginBlockEnd: "space",
  marginBlockStart: "space",
  marginInline: "space",
  marginInlineEnd: "space",
  marginInlineStart: "space",
  padding: "space",
  paddingTop: "space",
  paddingRight: "space",
  paddingBottom: "space",
  paddingLeft: "space",
  paddingBlock: "space",
  paddingBlockEnd: "space",
  paddingBlockStart: "space",
  paddingInline: "space",
  paddingInlineEnd: "space",
  paddingInlineStart: "space",
  top: "space",
  right: "space",
  bottom: "space",
  left: "space",
  fontSize: "fontSizes",
  backgroundColor: "colors",
  border: [ "", "borderStyles", "colors" ],
  borderColor: "colors",
  borderTopColor: "colors",
  borderRightColor: "colors",
  borderBottomColor: "colors",
  borderLeftColor: "colors",
  caretColor: "colors",
  color: "colors",
  columnRuleColor: "colors",
  outlineColor: "colors",
  fill: "colors",
  stroke: "colors",
  fontFamily: "fonts",
  fontWeight: "fontWeights",
  lineHeight: "lineHeights",
  letterSpacing: "letterSpacings",
  blockSize: "sizes",
  minBlockSize: "sizes",
  maxBlockSize: "sizes",
  inlineSize: "sizes",
  minInlineSize: "sizes",
  maxInlineSize: "sizes",
  width: "sizes",
  minWidth: "sizes",
  maxWidth: "sizes",
  height: "sizes",
  minHeight: "sizes",
  maxHeight: "sizes",
  flexBasis: "sizes",
  borderWidth: "borderWidths",
  borderTopWidth: "borderWidths",
  borderLeftWidth: "borderWidths",
  borderRightWidth: "borderWidths",
  borderBottomWidth: "borderWidths",
  borderStyle: "borderStyles",
  borderTopStyle: "borderStyles",
  borderLeftStyle: "borderStyles",
  borderRightStyle: "borderStyles",
  borderBottomStyle: "borderStyles",
  borderRadius: "radii",
  borderTopLeftRadius: "radii",
  borderTopRightRadius: "radii",
  borderBottomRightRadius: "radii",
  borderBottomLeftRadius: "radii",
  boxShadow: "shadows",
  textShadow: "shadows",
  zIndex: "zIndices",
  transition: "transitions"
}, tokenTypes$1 = [ "sizes", "colors", "space", "fontSizes", "lineHeights", "fontWeights", "fonts", "borderWidths", "radii" ], enhanceSheet = function(sheet) {
  return {
    content: sheet.content,
    cssRules: sheet.cssRules,
    insertRule: function(rule, index) {
      try {
        return sheet.insertRule(rule, index), index;
      } catch (_unused) {
        return -1;
      }
    }
  };
}, createSheets = function(env) {
  var screens = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}, tags = [];
  if (env && env.document) {
    var head = env.document.querySelector("head");
    if (!head) throw new Error("There is no HEAD element on this document");
    var styles = Array.from(head.querySelectorAll("style")), existingStyles = styles.filter((function(style) {
      return Boolean(style.textContent && style.textContent.startsWith("/* STITCHES"));
    }));
    return {
      tags: tags,
      sheets: [ "__variables__", "__keyframes__", MAIN_BREAKPOINT_ID ].concat(Object.keys(screens)).reduce((function(aggr, key, index) {
        var style = existingStyles[index];
        return style || (style = env.document.createElement("style"), head.appendChild(style)), 
        tags.push(style), aggr[key] = enhanceSheet(style.sheet), aggr;
      }), {})
    };
  }
  return {
    tags: tags,
    sheets: [ "__variables__", "__keyframes__", MAIN_BREAKPOINT_ID ].concat(Object.keys(screens)).reduce((function(aggr, key) {
      return aggr[key] = enhanceSheet({
        content: "",
        cssRules: [],
        insertRule: function(content) {
          var index = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0;
          this.cssRules.splice(index, 0, content);
        }
      }), aggr;
    }), {})
  };
}, specificityProps = {
  border: border,
  boxShadow: boxShadow,
  flex: function(tokens, value) {
    if (Array.isArray(value)) {
      if (2 === value.length) return _objectSpread({
        flexGrow: value[0]
      }, isNaN(value[1]) ? {
        flexBasis: value[1]
      } : {
        flexShrink: value[1]
      });
      if (3 === value.length) return {
        flexGrow: value[0],
        flexShrink: value[1],
        flexBasis: value[2]
      };
    }
    return isNaN(value) ? {
      flexBasis: value
    } : {
      flexGrow: value
    };
  },
  overflow: function(tokens, value) {
    return {
      overflowX: value,
      overflowY: value
    };
  },
  margin: margin,
  padding: padding,
  borderRadius: borderRadius,
  borderColor: borderColor,
  borderStyle: borderStyle,
  borderWidth: borderWidth,
  background: background,
  animation: animation,
  transition: transition,
  font: font,
  borderBottom: borderBottom,
  borderLeft: borderLeft,
  borderTop: borderTop,
  borderRight: borderRight,
  textDecoration: textDecoration
}, getVendorPrefixAndProps = function(env) {
  var styles = env.getComputedStyle(env.document.documentElement), vendorProps = Array.from(styles).filter((function(prop) {
    return "-" === prop[0];
  })), vendorPrefix = (vendorProps.join("").match(/-(moz|webkit|ms)-/) || "" === styles.OLink && [ "", "o" ])[1];
  return {
    vendorPrefix: "-".concat(vendorPrefix, "-"),
    vendorProps: vendorProps
  };
}, hashString = function(str) {
  for (var hash = 5381, i = str.length; i; ) hash = 33 * hash ^ str.charCodeAt(--i);
  return generateAlphabeticName(hash >>> 0);
}, AD_REPLACER_R = /(a)(d)/gi, charsLength = 52, getAlphabeticChar = function(code) {
  return String.fromCharCode(code + (code > 25 ? 39 : 97));
};

function generateAlphabeticName(code) {
  var x, name = "";
  for (x = Math.abs(code); x > charsLength; x = x / charsLength | 0) name = getAlphabeticChar(x % charsLength) + name;
  return (getAlphabeticChar(x % charsLength) + name).replace(AD_REPLACER_R, "$1-$2");
}

function _slicedToArray$1(arr, i) {
  return _arrayWithHoles$1(arr) || _iterableToArrayLimit$1(arr, i) || _unsupportedIterableToArray$1(arr, i) || _nonIterableRest$1();
}

function _nonIterableRest$1() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

function _iterableToArrayLimit$1(arr, i) {
  if ("undefined" != typeof Symbol && Symbol.iterator in Object(arr)) {
    var _arr = [], _n = !0, _d = !1, _e = void 0;
    try {
      for (var _s, _i = arr[Symbol.iterator](); !(_n = (_s = _i.next()).done) && (_arr.push(_s.value), 
      !i || _arr.length !== i); _n = !0) ;
    } catch (err) {
      _d = !0, _e = err;
    } finally {
      try {
        _n || null == _i.return || _i.return();
      } finally {
        if (_d) throw _e;
      }
    }
    return _arr;
  }
}

function _arrayWithHoles$1(arr) {
  if (Array.isArray(arr)) return arr;
}

function _defineProperty$1(obj, key, value) {
  return key in obj ? Object.defineProperty(obj, key, {
    value: value,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : obj[key] = value, obj;
}

function _createForOfIteratorHelper(o, allowArrayLike) {
  var it;
  if ("undefined" == typeof Symbol || null == o[Symbol.iterator]) {
    if (Array.isArray(o) || (it = _unsupportedIterableToArray$1(o)) || allowArrayLike && o && "number" == typeof o.length) {
      it && (o = it);
      var i = 0, F = function() {};
      return {
        s: F,
        n: function() {
          return i >= o.length ? {
            done: !0
          } : {
            done: !1,
            value: o[i++]
          };
        },
        e: function(_e2) {
          throw _e2;
        },
        f: F
      };
    }
    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }
  var err, normalCompletion = !0, didErr = !1;
  return {
    s: function() {
      it = o[Symbol.iterator]();
    },
    n: function() {
      var step = it.next();
      return normalCompletion = step.done, step;
    },
    e: function(_e3) {
      didErr = !0, err = _e3;
    },
    f: function() {
      try {
        normalCompletion || null == it.return || it.return();
      } finally {
        if (didErr) throw err;
      }
    }
  };
}

function _toConsumableArray(arr) {
  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray$1(arr) || _nonIterableSpread();
}

function _nonIterableSpread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

function _unsupportedIterableToArray$1(o, minLen) {
  if (o) {
    if ("string" == typeof o) return _arrayLikeToArray$1(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    return "Object" === n && o.constructor && (n = o.constructor.name), "Map" === n || "Set" === n ? Array.from(o) : "Arguments" === n || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n) ? _arrayLikeToArray$1(o, minLen) : void 0;
  }
}

function _iterableToArray(iter) {
  if ("undefined" != typeof Symbol && Symbol.iterator in Object(iter)) return Array.from(iter);
}

function _arrayWithoutHoles(arr) {
  if (Array.isArray(arr)) return _arrayLikeToArray$1(arr);
}

function _arrayLikeToArray$1(arr, len) {
  (null == len || len > arr.length) && (len = arr.length);
  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];
  return arr2;
}

function _typeof(obj) {
  return (_typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj) {
    return typeof obj;
  } : function(obj) {
    return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
  })(obj);
}

var _ATOM = ATOM, hotReloadingCache = new Map, cleanSSRClass = function(s) {
  return s.replace(/(\/\*X\*\/|\\([^-_a-zA-Z\d]*))/g, "$2");
}, createSSRCssRuleClass = function(s) {
  return "/*X*/".concat(s.replace(/[^-_a-zA-Z\d]/g, "\\$&"), "/*X*/");
}, createSelector = function(className, selector) {
  var cssRuleClassName = className ? ".".concat(className) : "";
  return selector && selector.includes("&") ? selector.replace(/&/gi, cssRuleClassName) : selector ? "".concat(cssRuleClassName).concat(selector) : cssRuleClassName;
}, resolveTokens = function(cssProp, value, tokens) {
  var token = cssPropToToken[cssProp];
  return token ? Array.isArray(token) && Array.isArray(value) ? token.map((function(tokenName, index) {
    return token && tokens[tokenName] && tokens[tokenName][value[index]] ? tokens[tokenName][value[index]] : value[index];
  })) : token && tokens[token] && tokens[token][value] ? tokens[token][value] : value : value;
}, processStyleObject = function processStyleObject(obj, config, valueMiddleware) {
  for (var currentNestingPath = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : [], shouldHandleUtils = !(arguments.length > 4 && void 0 !== arguments[4]) || arguments[4], shouldHandleSpecificityProps = !(arguments.length > 5 && void 0 !== arguments[5]) || arguments[5], _i = 0, _Object$keys = Object.keys(obj); _i < _Object$keys.length; _i++) {
    var key = _Object$keys[_i], val = obj[key], isUtilProp = shouldHandleUtils && key in config.utils, isSpecificityProp = shouldHandleSpecificityProps && !isUtilProp && key in specificityProps;
    if ("object" !== _typeof(val) || isSpecificityProp || isUtilProp) if (isUtilProp) {
      var resolvedUtils = config.utils[key](val, config);
      processStyleObject(resolvedUtils, config, valueMiddleware, _toConsumableArray(currentNestingPath), !1);
    } else if (isSpecificityProp) {
      var resolvedSpecificityProps = specificityProps[key](config.tokens, val);
      processStyleObject(resolvedSpecificityProps, config, valueMiddleware, _toConsumableArray(currentNestingPath), !1, !1);
    } else "number" == typeof val ? valueMiddleware(key, "".concat(unitlessKeys[key] ? val : val + "px"), currentNestingPath) : void 0 !== val && valueMiddleware(key, resolveTokens(key, val, config.tokens), currentNestingPath); else {
      if (val[ATOM]) {
        valueMiddleware(key, val, currentNestingPath);
        continue;
      }
      processStyleObject(val, config, valueMiddleware, [].concat(_toConsumableArray(currentNestingPath), [ key ]));
    }
  }
}, resolveBreakpointAndSelectorAndInlineMedia = function(nestingPath, config) {
  return nestingPath.reduce((function(acc, breakpointOrSelector, i) {
    return breakpointOrSelector in config.breakpoints || breakpointOrSelector === MAIN_BREAKPOINT_ID ? (acc.breakpoint = breakpointOrSelector, 
    acc) : "@" === breakpointOrSelector[0] ? (acc.inlineMediaQueries.push(breakpointOrSelector), 
    acc) : (acc.nestingPath = acc.nestingPath + ("&" === breakpointOrSelector[0] && ":" === breakpointOrSelector[1] ? breakpointOrSelector.substr(1) : ":" === breakpointOrSelector[0] ? breakpointOrSelector : " " + breakpointOrSelector), 
    acc);
  }), {
    breakpoint: MAIN_BREAKPOINT_ID,
    nestingPath: "",
    inlineMediaQueries: []
  });
}, hyphenAndVendorPrefixCssProp = function(cssProp, vendorProps, vendorPrefix) {
  var isVendorPrefixed = cssProp[0] === cssProp[0].toUpperCase(), cssHyphenProp = cssProp.split(/(?=[A-Z])/).map((function(g) {
    return g.toLowerCase();
  })).join("-");
  return isVendorPrefixed ? cssHyphenProp = "-".concat(cssHyphenProp) : vendorProps.includes("".concat(vendorPrefix).concat(cssHyphenProp)) && (cssHyphenProp = "".concat(vendorPrefix).concat(cssHyphenProp)), 
  cssHyphenProp;
}, toStringCachedAtom = function() {
  return this._className;
}, toStringCompose = function() {
  var className = this.atoms.map((function(atom) {
    return atom.toString();
  })).join(" ");
  return this._className = className, isServer || (this.toString = toStringCachedAtom), 
  className;
}, createCssRule = function(breakpoints, atom, className) {
  var cssRule = "";
  if (atom.inlineMediaQueries && atom.inlineMediaQueries.length) {
    var allMediaQueries = "", endBrackets = "";
    atom.inlineMediaQueries.forEach((function(breakpoint) {
      allMediaQueries += "".concat(breakpoint, "{"), endBrackets += "}";
    })), cssRule = "".concat(allMediaQueries).concat(createSelector(className, atom.selector), "{").concat(atom.cssHyphenProp, ":").concat(atom.value, ";}").concat(endBrackets);
  } else cssRule = "".concat(createSelector(className, atom.selector), "{").concat(atom.cssHyphenProp, ":").concat(atom.value, ";}");
  return atom.breakpoint !== MAIN_BREAKPOINT_ID ? breakpoints[atom.breakpoint](cssRule) : cssRule;
}, createToString = function(sheets) {
  var breakpoints = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}, cssClassnameProvider = arguments.length > 2 ? arguments[2] : void 0, preInjectedRules = arguments.length > 3 ? arguments[3] : void 0;
  return function() {
    var className = cssClassnameProvider(this);
    if (!preInjectedRules.size || !preInjectedRules.has(".".concat(className))) {
      var sheet = sheets[this.breakpoint];
      sheet.insertRule(createCssRule(breakpoints, this, className), this.inlineMediaQueries.length ? sheet.cssRules.length : 0);
    }
    return this.cssHyphenProp = this.value = this.pseudo = this.breakpoint = this.inlineMediaQueries = void 0, 
    this._className = className, this.toString = toStringCachedAtom, className;
  };
}, createServerToString = function(sheets) {
  var breakpoints = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}, cssClassnameProvider = arguments.length > 2 ? arguments[2] : void 0;
  return function() {
    var className = cssClassnameProvider(this), sheet = sheets[this.breakpoint];
    return sheets[this.breakpoint].insertRule(createCssRule(breakpoints, this, className.length ? createSSRCssRuleClass(className) : ""), this.inlineMediaQueries.length ? sheet.cssRules.length : 0), 
    this._className = className, this.toString = toStringCachedAtom, className;
  };
}, createThemeToString = function(classPrefix, variablesSheet) {
  return function() {
    var _this = this, themeClassName = "".concat(classPrefix ? "".concat(classPrefix, "-") : "", "theme-").concat(this.name);
    return variablesSheet.insertRule(".".concat(themeClassName, "{").concat(Object.keys(this.definition).reduce((function(aggr, tokenType) {
      return "".concat(aggr).concat(Object.keys(_this.definition[tokenType]).reduce((function(subAggr, tokenKey) {
        return "".concat(subAggr, "--").concat(tokenType, "-").concat(tokenKey.replace(/[^\w\s-]/gi, ""), ":").concat(_this.definition[tokenType][tokenKey], ";");
      }), aggr));
    }), ""), "}")), this.toString = function() {
      return themeClassName;
    }, themeClassName;
  };
}, createKeyframesToString = function(sheet) {
  return function() {
    var _this2 = this;
    return this._cssRuleString && sheet.insertRule(this._cssRuleString), this.toString = function() {
      return _this2.id;
    }, this.id;
  };
}, composeIntoMap = function composeIntoMap(map, atoms) {
  for (var i = atoms.length - 1; i >= 0; i--) {
    var item = atoms[i];
    item && item[ATOM] && "atoms" in item ? composeIntoMap(map, item.atoms) : item && item[ATOM] ? map.has(item.id) || map.set(item.id, item) : item && map.set(item, item);
  }
}, createTokens = function(tokens) {
  return tokens;
}, createCss = function(_config) {
  var _window, env = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "undefined" == typeof window || (null === (_window = window) || void 0 === _window ? void 0 : _window.Deno) ? null : window, config = Object.assign({
    tokens: {},
    utils: {},
    breakpoints: {}
  }, _config);
  tokenTypes.forEach((function(tokenType) {
    return config.tokens[tokenType] = config.tokens[tokenType] || {};
  }));
  var tokens = config.tokens, breakpoints = config.breakpoints, showFriendlyClassnames = "boolean" == typeof config.showFriendlyClassnames && config.showFriendlyClassnames, prefix = config.prefix || "", _ref = env ? getVendorPrefixAndProps(env) : {
    vendorPrefix: "-node-",
    vendorProps: []
  }, vendorPrefix = _ref.vendorPrefix, vendorProps = _ref.vendorProps;
  if (env && hotReloadingCache.has(prefix)) {
    var instance = hotReloadingCache.get(prefix);
    instance.dispose();
  }
  var _step, classPrefix = prefix ? showFriendlyClassnames ? "".concat(prefix, "_") : prefix : "", cssClassnameProvider = function(atom) {
    var _atom$inlineMediaQuer;
    if (atom._isGlobal) return "";
    var hash = hashString("".concat(atom.breakpoint || "").concat(atom.cssHyphenProp.replace(/-(moz|webkit|ms)-/, "")).concat(atom.selector || "").concat((null === (_atom$inlineMediaQuer = atom.inlineMediaQueries) || void 0 === _atom$inlineMediaQuer ? void 0 : _atom$inlineMediaQuer.join("")) || "").concat(atom.value)), name = showFriendlyClassnames ? "".concat(atom.breakpoint ? "_".concat(atom.breakpoint, "_") : "").concat(atom.cssHyphenProp.replace(/-(moz|webkit|ms)-/, "").split("-").map((function(part) {
      return part[0];
    })).join(""), "_").concat(hash) : "_".concat(hash);
    return "".concat(classPrefix).concat(name);
  }, _createSheets = createSheets(env, config.breakpoints), tags = _createSheets.tags, sheets = _createSheets.sheets, preInjectedRules = new Set, _iterator = _createForOfIteratorHelper(tags);
  try {
    for (_iterator.s(); !(_step = _iterator.n()).done; ) {
      var tag = _step.value;
      ((tag.textContent || "").match(/\/\*\X\*\/.*?\/\*\X\*\//g) || []).forEach((function(rule) {
        preInjectedRules.add("." + cleanSSRClass(rule));
      }));
    }
  } catch (err) {
    _iterator.e(err);
  } finally {
    _iterator.f();
  }
  var toString = env ? createToString(sheets, config.breakpoints, cssClassnameProvider, preInjectedRules) : createServerToString(sheets, config.breakpoints, cssClassnameProvider), themeToString = createThemeToString(classPrefix, sheets.__variables__), keyframesToString = createKeyframesToString(sheets.__keyframes__), compose = function() {
    for (var map = new Map, _len = arguments.length, atoms = new Array(_len), _key = 0; _key < _len; _key++) atoms[_key] = arguments[_key];
    return composeIntoMap(map, atoms), _defineProperty$1({
      atoms: Array.from(map.values()),
      toString: toStringCompose
    }, ATOM, !0);
  }, createAtom = function(cssProp, value) {
    var _selectorString, _atom, breakpoint = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : MAIN_BREAKPOINT_ID, selectorString = arguments.length > 3 ? arguments[3] : void 0, inlineMediaQueries = arguments.length > 4 ? arguments[4] : void 0, isGlobal = arguments.length > 5 ? arguments[5] : void 0, inlineMediasAsString = inlineMediaQueries ? inlineMediaQueries.join("") : "", id = cssProp.toLowerCase() + selectorString + (inlineMediaQueries ? inlineMediaQueries.join("") : "") + breakpoint, uid = id + value;
    if (atomCache.has(uid)) return inlineMediasAsString.match(/@media.*\((min|max)?.*(width|height).*\)/) && console.warn('The property "'.concat(cssProp, '" with media query ').concat(inlineMediasAsString, " can cause a specificity issue. You should create a breakpoint")), 
    atomCache.get(uid);
    var _selectorString2, _selectorString3, _selectorString4, _selectorString5, _selectorString6, cssHyphenProp = hyphenAndVendorPrefixCssProp(cssProp, vendorProps, vendorPrefix);
    (null === (_selectorString = selectorString) || void 0 === _selectorString ? void 0 : _selectorString.match("&")) || ((null === (_selectorString2 = selectorString) || void 0 === _selectorString2 ? void 0 : _selectorString2.match(/\:hover/)) ? selectorString = "&&".concat(selectorString) : (null === (_selectorString3 = selectorString) || void 0 === _selectorString3 ? void 0 : _selectorString3.match(/\:active/)) ? selectorString = "&&&".concat(selectorString) : (null === (_selectorString4 = selectorString) || void 0 === _selectorString4 ? void 0 : _selectorString4.match(/\:focus|\:focus-visible/)) ? selectorString = "&&&&".concat(selectorString) : (null === (_selectorString5 = selectorString) || void 0 === _selectorString5 ? void 0 : _selectorString5.match(/\:read-only/)) ? selectorString = "&&&&&".concat(selectorString) : (null === (_selectorString6 = selectorString) || void 0 === _selectorString6 ? void 0 : _selectorString6.match(/\:disabled/)) && (selectorString = "&&&&&&".concat(selectorString)));
    var atom = (_defineProperty$1(_atom = {
      id: id,
      cssHyphenProp: cssHyphenProp,
      value: value,
      selector: selectorString,
      inlineMediaQueries: inlineMediaQueries,
      breakpoint: breakpoint,
      toString: toString
    }, ATOM, !0), _defineProperty$1(_atom, "_isGlobal", isGlobal), _atom);
    return atomCache.set(uid, atom), atom;
  }, baseTokens = ":root{";
  for (var tokenType in tokens) for (var isNumericScale = tokenType.match(/^(sizes|space|letterSpacings|zIndices)$/), scaleTokenKeys = Object.keys(tokens[tokenType]), index = 0; index < scaleTokenKeys.length; index++) {
    var token = scaleTokenKeys[index], formattedToken = token.replace(/[^\w\s-]/gi, ""), cssVar = "--".concat(tokenType, "-").concat(formattedToken);
    baseTokens += "".concat(cssVar, ":").concat(tokens[tokenType][token], ";"), tokens[tokenType][token] = "var(".concat(cssVar, ")");
    var negativeTokenKey = "-" + token, isAlreadyANegativeToken = "-" === token[0] && !!tokens[tokenType][token.substring(1)];
    !isNumericScale || tokens[tokenType][negativeTokenKey] || isAlreadyANegativeToken || (tokens[tokenType][negativeTokenKey] = "calc(var(".concat(cssVar, ") * -1)"));
  }
  baseTokens += "}", preInjectedRules.has(":root") || sheets.__variables__.insertRule(baseTokens);
  var atomCache = new Map, keyFramesCache = new Map, themeCache = new Map, cssInstance = function() {
    for (var args = [], index = 0, _len2 = arguments.length, definitions = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) definitions[_key2] = arguments[_key2];
    for (var x = 0; x < definitions.length; x++) definitions[x] && ("string" == typeof definitions[x] || definitions[x][ATOM] ? args[index++] = definitions[x] : processStyleObject(definitions[x], config, (function(prop, value, path) {
      var _resolveBreakpointAnd = resolveBreakpointAndSelectorAndInlineMedia(path, config), nestingPath = _resolveBreakpointAnd.nestingPath, breakpoint = _resolveBreakpointAnd.breakpoint, inlineMediaQueries = _resolveBreakpointAnd.inlineMediaQueries;
      args[index++] = createAtom(prop, value, breakpoint, nestingPath, inlineMediaQueries);
    })));
    var composition = compose.apply(void 0, args);
    return composition;
  };
  return cssInstance.dispose = function() {
    atomCache.clear(), tags.forEach((function(tag) {
      var _tag$parentNode;
      null === (_tag$parentNode = tag.parentNode) || void 0 === _tag$parentNode || _tag$parentNode.removeChild(tag);
    }));
  }, cssInstance._config = function() {
    return config;
  }, cssInstance.theme = function(definition) {
    if (themeCache.has(definition)) return themeCache.get(definition);
    var themeAtom = _defineProperty$1({
      name: String(themeCache.size),
      definition: definition,
      toString: themeToString
    }, ATOM, !0);
    return themeCache.set(definition, themeAtom), themeAtom;
  }, cssInstance.global = function(definitions) {
    var atoms = [];
    return processStyleObject(definitions, config, (function(prop, value, path) {
      var _resolveBreakpointAnd2 = resolveBreakpointAndSelectorAndInlineMedia(path, config), nestingPath = _resolveBreakpointAnd2.nestingPath, breakpoint = _resolveBreakpointAnd2.breakpoint, inlineMediaQueries = _resolveBreakpointAnd2.inlineMediaQueries;
      if (!nestingPath.length) throw new Error("Global styles need to be nested within a selector");
      atoms.push(createAtom(prop, value, breakpoint, nestingPath, inlineMediaQueries, !0));
    })), function() {
      return compose.apply(void 0, atoms).toString();
    };
  }, cssInstance.keyframes = function(definition) {
    var cssRule = "", currentTimeProp = "";
    processStyleObject(definition, config, (function(key, value, _ref3) {
      var timeProp = _slicedToArray$1(_ref3, 1)[0];
      timeProp !== currentTimeProp && (cssRule && (cssRule += "}"), currentTimeProp = timeProp, 
      cssRule += "".concat(timeProp, " {")), cssRule += "".concat(hyphenAndVendorPrefixCssProp(key, vendorProps, vendorPrefix), ": ").concat(resolveTokens(key, value, tokens), ";");
    }));
    var hash = hashString(cssRule += "}"), cachedAtom = keyFramesCache.get(hash);
    if (cachedAtom) return cachedAtom;
    cssRule = "@keyframes ".concat(hash, " {").concat(cssRule, "}");
    var keyframesAtom = _defineProperty$1({
      id: String(hash),
      _cssRuleString: cssRule,
      toString: keyframesToString
    }, ATOM, !0);
    return keyFramesCache.set(hash, keyframesAtom), keyframesAtom;
  }, cssInstance.getStyles = function(cb) {
    for (var sheet in sheets) "__keyframes__" !== sheet && (sheets[sheet].cssRules.length = 0);
    return baseTokens && sheets.__variables__.insertRule(baseTokens), toString = createServerToString(sheets, config.breakpoints, cssClassnameProvider), 
    keyframesToString = createKeyframesToString(sheets[MAIN_BREAKPOINT_ID]), themeToString = createThemeToString(classPrefix, sheets.__variables__), 
    atomCache.forEach((function(atom) {
      atom.toString = toString;
    })), keyFramesCache.forEach((function(atom) {
      atom.toString = keyframesToString;
    })), themeCache.forEach((function(atom) {
      atom.toString = themeToString;
    })), {
      result: cb(),
      styles: Object.keys(breakpoints).reduce((function(aggr, key) {
        return aggr.concat("/* STITCHES:".concat(key, " */\n").concat(sheets[key].cssRules.join("\n")));
      }), [ "/* STITCHES:__variables__ */\n".concat(sheets.__variables__.cssRules.join("\n")), "/* STITCHES:__keyframes__ */\n".concat(sheets.__keyframes__.cssRules.join("\n")), "/* STITCHES */\n".concat(sheets[MAIN_BREAKPOINT_ID].cssRules.join("\n")) ])
    };
  }, env && hotReloadingCache.set(prefix, cssInstance), cssInstance;
};

exports.ATOM = ATOM, exports.MAIN_BREAKPOINT_ID = MAIN_BREAKPOINT_ID, exports._ATOM = _ATOM, 
exports.createCss = createCss, exports.createSheets = createSheets, exports.createTokens = createTokens, 
exports.cssPropToToken = cssPropToToken, exports.getVendorPrefixAndProps = getVendorPrefixAndProps, 
exports.hashString = hashString, exports.hotReloadingCache = hotReloadingCache, 
exports.specificityProps = specificityProps, exports.tokenTypes = tokenTypes$1;
