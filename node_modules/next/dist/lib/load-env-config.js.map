{"version":3,"sources":["../../lib/load-env-config.ts"],"names":["combinedEnv","undefined","cachedLoadedEnvFiles","processEnv","loadedEnvFiles","dir","process","env","__NEXT_PROCESSED_ENV","length","envFile","result","parsed","dotenv","parse","contents","log","info","path","join","Object","assign","err","error","loadEnvConfig","dev","isTest","NODE_ENV","mode","dotenvFiles","filter","Boolean","dotEnvPath","stats","fs","statSync","isFile","readFileSync","push","code"],"mappings":"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","sourcesContent":["import fs from 'fs'\nimport path from 'path'\nimport * as log from '../build/output/log'\nimport dotenvExpand from 'next/dist/compiled/dotenv-expand'\nimport dotenv, { DotenvConfigOutput } from 'next/dist/compiled/dotenv'\n\nexport type Env = { [key: string]: string }\nexport type LoadedEnvFiles = Array<{\n  path: string\n  contents: string\n}>\n\nlet combinedEnv: Env | undefined = undefined\nlet cachedLoadedEnvFiles: LoadedEnvFiles = []\n\nexport function processEnv(loadedEnvFiles: LoadedEnvFiles, dir?: string) {\n  // don't reload env if we already have since this breaks escaped\n  // environment values e.g. \\$ENV_FILE_KEY\n  if (\n    combinedEnv ||\n    process.env.__NEXT_PROCESSED_ENV ||\n    !loadedEnvFiles.length\n  ) {\n    return process.env as Env\n  }\n  // flag that we processed the environment values in case a serverless\n  // function is re-used or we are running in `next start` mode\n  process.env.__NEXT_PROCESSED_ENV = 'true'\n\n  for (const envFile of loadedEnvFiles) {\n    try {\n      let result: DotenvConfigOutput = {}\n      result.parsed = dotenv.parse(envFile.contents)\n\n      result = dotenvExpand(result)\n\n      if (result.parsed) {\n        log.info(`Loaded env from ${path.join(dir || '', envFile.path)}`)\n      }\n\n      Object.assign(process.env, result.parsed)\n    } catch (err) {\n      log.error(\n        `Failed to load env from ${path.join(dir || '', envFile.path)}`,\n        err\n      )\n    }\n  }\n\n  return process.env as Env\n}\n\nexport function loadEnvConfig(\n  dir: string,\n  dev?: boolean\n): {\n  combinedEnv: Env\n  loadedEnvFiles: LoadedEnvFiles\n} {\n  // don't reload env if we already have since this breaks escaped\n  // environment values e.g. \\$ENV_FILE_KEY\n  if (combinedEnv) return { combinedEnv, loadedEnvFiles: cachedLoadedEnvFiles }\n\n  const isTest = process.env.NODE_ENV === 'test'\n  const mode = isTest ? 'test' : dev ? 'development' : 'production'\n  const dotenvFiles = [\n    `.env.${mode}.local`,\n    // Don't include `.env.local` for `test` environment\n    // since normally you expect tests to produce the same\n    // results for everyone\n    mode !== 'test' && `.env.local`,\n    `.env.${mode}`,\n    '.env',\n  ].filter(Boolean) as string[]\n\n  for (const envFile of dotenvFiles) {\n    // only load .env if the user provided has an env config file\n    const dotEnvPath = path.join(dir, envFile)\n\n    try {\n      const stats = fs.statSync(dotEnvPath)\n\n      // make sure to only attempt to read files\n      if (!stats.isFile()) {\n        continue\n      }\n\n      const contents = fs.readFileSync(dotEnvPath, 'utf8')\n      cachedLoadedEnvFiles.push({\n        path: envFile,\n        contents,\n      })\n    } catch (err) {\n      if (err.code !== 'ENOENT') {\n        log.error(`Failed to load env from ${envFile}`, err)\n      }\n    }\n  }\n  combinedEnv = processEnv(cachedLoadedEnvFiles, dir)\n  return { combinedEnv, loadedEnvFiles: cachedLoadedEnvFiles }\n}\n"]}