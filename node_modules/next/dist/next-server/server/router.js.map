{"version":3,"sources":["../../../next-server/server/router.ts"],"names":["route","customRouteTypes","Set","prepareDestination","destination","params","query","appendParamsToQuery","basePath","parsedDestination","destQuery","destinationCompiler","pathname","hash","validate","newUrl","key","strOrArray","Object","entries","value","Array","isArray","queryCompiler","substr","name","shouldAddBasePath","startsWith","encodeURI","split","path","search","err","message","match","Error","replaceBasePath","replace","Router","constructor","headers","fsRoutes","rewrites","redirects","catchAllRoute","dynamicRoutes","pageChecker","useFileSystemPublicRoutes","setDynamicRoutes","routes","addFsRoute","fsRoute","unshift","execute","req","res","parsedUrl","pageChecks","memoizedPageChecker","p","result","parsedUrlUpdated","allRoutes","type","requireBasePath","fn","checkerReq","checkerRes","parsedCheckerUrl","finished","originallyHadBasePath","_nextHadBasePath","testRoute","currentPathname","originalPathname","isCustomRoute","has","newParams","_nextDidRewrite","check","originalFsPathname","fsPathname","fsParams","fsResult","matchedPage","dynamicRoute","pageParams"],"mappings":"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","sourcesContent":["import { IncomingMessage, ServerResponse } from 'http'\nimport { parse as parseUrl, UrlWithParsedQuery } from 'url'\nimport { ParsedUrlQuery } from 'querystring'\nimport { compile as compilePathToRegex } from 'next/dist/compiled/path-to-regexp'\nimport pathMatch from './lib/path-match'\n\nexport const route = pathMatch()\n\nexport type Params = { [param: string]: any }\n\nexport type RouteMatch = (pathname: string | null | undefined) => false | Params\n\ntype RouteResult = {\n  finished: boolean\n  pathname?: string\n  query?: { [k: string]: string }\n}\n\nexport type Route = {\n  match: RouteMatch\n  type: string\n  check?: boolean\n  statusCode?: number\n  name: string\n  requireBasePath?: false\n  fn: (\n    req: IncomingMessage,\n    res: ServerResponse,\n    params: Params,\n    parsedUrl: UrlWithParsedQuery\n  ) => Promise<RouteResult> | RouteResult\n}\n\nexport type DynamicRoutes = Array<{ page: string; match: RouteMatch }>\n\nexport type PageChecker = (pathname: string) => Promise<boolean>\n\nconst customRouteTypes = new Set(['rewrite', 'redirect', 'header'])\n\nexport const prepareDestination = (\n  destination: string,\n  params: Params,\n  query: ParsedUrlQuery,\n  appendParamsToQuery: boolean,\n  basePath: string\n) => {\n  const parsedDestination = parseUrl(destination, true)\n  const destQuery = parsedDestination.query\n  let destinationCompiler = compilePathToRegex(\n    `${parsedDestination.pathname!}${parsedDestination.hash || ''}`,\n    // we don't validate while compiling the destination since we should\n    // have already validated before we got to this point and validating\n    // breaks compiling destinations with named pattern params from the source\n    // e.g. /something:hello(.*) -> /another/:hello is broken with validation\n    // since compile validation is meant for reversing and not for inserting\n    // params from a separate path-regex into another\n    { validate: false }\n  )\n  let newUrl\n\n  // update any params in query values\n  for (const [key, strOrArray] of Object.entries(destQuery)) {\n    let value = Array.isArray(strOrArray) ? strOrArray[0] : strOrArray\n    if (value) {\n      // the value needs to start with a forward-slash to be compiled\n      // correctly\n      value = `/${value}`\n      const queryCompiler = compilePathToRegex(value, { validate: false })\n      value = queryCompiler(params).substr(1)\n    }\n    destQuery[key] = value\n  }\n\n  // add path params to query if it's not a redirect and not\n  // already defined in destination query\n  if (appendParamsToQuery) {\n    for (const [name, value] of Object.entries(params)) {\n      if (!(name in destQuery)) {\n        destQuery[name] = value\n      }\n    }\n  }\n\n  const shouldAddBasePath = destination.startsWith('/') && basePath\n\n  try {\n    newUrl = `${shouldAddBasePath ? basePath : ''}${encodeURI(\n      destinationCompiler(params)\n    )}`\n\n    const [pathname, hash] = newUrl.split('#')\n    parsedDestination.pathname = pathname\n    parsedDestination.hash = `${hash ? '#' : ''}${hash || ''}`\n    parsedDestination.path = `${pathname}${parsedDestination.search}`\n    delete parsedDestination.search\n  } catch (err) {\n    if (err.message.match(/Expected .*? to not repeat, but got an array/)) {\n      throw new Error(\n        `To use a multi-match in the destination you must add \\`*\\` at the end of the param name to signify it should repeat. https://err.sh/vercel/next.js/invalid-multi-match`\n      )\n    }\n    throw err\n  }\n\n  // Query merge order lowest priority to highest\n  // 1. initial URL query values\n  // 2. path segment values\n  // 3. destination specified query values\n  parsedDestination.query = {\n    ...query,\n    ...parsedDestination.query,\n  }\n\n  return {\n    newUrl,\n    parsedDestination,\n  }\n}\n\nfunction replaceBasePath(basePath: string, pathname: string) {\n  return pathname!.replace(basePath, '') || '/'\n}\n\nexport default class Router {\n  basePath: string\n  headers: Route[]\n  fsRoutes: Route[]\n  rewrites: Route[]\n  redirects: Route[]\n  catchAllRoute: Route\n  pageChecker: PageChecker\n  dynamicRoutes: DynamicRoutes\n  useFileSystemPublicRoutes: boolean\n\n  constructor({\n    basePath = '',\n    headers = [],\n    fsRoutes = [],\n    rewrites = [],\n    redirects = [],\n    catchAllRoute,\n    dynamicRoutes = [],\n    pageChecker,\n    useFileSystemPublicRoutes,\n  }: {\n    basePath: string\n    headers: Route[]\n    fsRoutes: Route[]\n    rewrites: Route[]\n    redirects: Route[]\n    catchAllRoute: Route\n    dynamicRoutes: DynamicRoutes | undefined\n    pageChecker: PageChecker\n    useFileSystemPublicRoutes: boolean\n  }) {\n    this.basePath = basePath\n    this.headers = headers\n    this.fsRoutes = fsRoutes\n    this.rewrites = rewrites\n    this.redirects = redirects\n    this.pageChecker = pageChecker\n    this.catchAllRoute = catchAllRoute\n    this.dynamicRoutes = dynamicRoutes\n    this.useFileSystemPublicRoutes = useFileSystemPublicRoutes\n  }\n\n  setDynamicRoutes(routes: DynamicRoutes = []) {\n    this.dynamicRoutes = routes\n  }\n\n  addFsRoute(fsRoute: Route) {\n    this.fsRoutes.unshift(fsRoute)\n  }\n\n  async execute(\n    req: IncomingMessage,\n    res: ServerResponse,\n    parsedUrl: UrlWithParsedQuery\n  ): Promise<boolean> {\n    // memoize page check calls so we don't duplicate checks for pages\n    const pageChecks: { [name: string]: Promise<boolean> } = {}\n    const memoizedPageChecker = async (p: string): Promise<boolean> => {\n      if (pageChecks[p]) {\n        return pageChecks[p]\n      }\n      const result = this.pageChecker(p)\n      pageChecks[p] = result\n      return result\n    }\n\n    let parsedUrlUpdated = parsedUrl\n\n    /*\n      Desired routes order\n      - headers\n      - redirects\n      - Check filesystem (including pages), if nothing found continue\n      - User rewrites (checking filesystem and pages each match)\n    */\n\n    const allRoutes = [\n      ...this.headers,\n      ...this.redirects,\n      ...this.fsRoutes,\n      // We only check the catch-all route if public page routes hasn't been\n      // disabled\n      ...(this.useFileSystemPublicRoutes\n        ? [\n            {\n              type: 'route',\n              name: 'page checker',\n              requireBasePath: false,\n              match: route('/:path*'),\n              fn: async (checkerReq, checkerRes, params, parsedCheckerUrl) => {\n                const { pathname } = parsedCheckerUrl\n\n                if (!pathname) {\n                  return { finished: false }\n                }\n                if (await memoizedPageChecker(pathname)) {\n                  return this.catchAllRoute.fn(\n                    checkerReq,\n                    checkerRes,\n                    params,\n                    parsedCheckerUrl\n                  )\n                }\n                return { finished: false }\n              },\n            } as Route,\n          ]\n        : []),\n      ...this.rewrites,\n      // We only check the catch-all route if public page routes hasn't been\n      // disabled\n      ...(this.useFileSystemPublicRoutes ? [this.catchAllRoute] : []),\n    ]\n    const originallyHadBasePath =\n      !this.basePath || (req as any)._nextHadBasePath\n\n    for (const testRoute of allRoutes) {\n      // if basePath is being used, the basePath will still be included\n      // in the pathname here to allow custom-routes to require containing\n      // it or not, filesystem routes and pages must always include the basePath\n      // if it is set\n      let currentPathname = parsedUrlUpdated.pathname\n      const originalPathname = currentPathname\n      const requireBasePath = testRoute.requireBasePath !== false\n      const isCustomRoute = customRouteTypes.has(testRoute.type)\n\n      if (!isCustomRoute) {\n        // If replace ends up replacing the full url it'll be `undefined`, meaning we have to default it to `/`\n        currentPathname = replaceBasePath(this.basePath, currentPathname!)\n      }\n\n      const newParams = testRoute.match(currentPathname)\n\n      // Check if the match function matched\n      if (newParams) {\n        // since we require basePath be present for non-custom-routes we\n        // 404 here when we matched an fs route\n        if (!isCustomRoute) {\n          if (!originallyHadBasePath && !(req as any)._nextDidRewrite) {\n            if (requireBasePath) {\n              // consider this a non-match so the 404 renders\n              return false\n            }\n            // page checker occurs before rewrites so we need to continue\n            // to check those since they don't always require basePath\n            continue\n          }\n\n          parsedUrlUpdated.pathname = currentPathname\n        }\n\n        const result = await testRoute.fn(req, res, newParams, parsedUrlUpdated)\n\n        // The response was handled\n        if (result.finished) {\n          return true\n        }\n\n        // since the fs route didn't match we need to re-add the basePath\n        // to continue checking rewrites with the basePath present\n        if (!isCustomRoute) {\n          parsedUrlUpdated.pathname = originalPathname\n        }\n\n        if (result.pathname) {\n          parsedUrlUpdated.pathname = result.pathname\n        }\n\n        if (result.query) {\n          parsedUrlUpdated.query = {\n            ...parsedUrlUpdated.query,\n            ...result.query,\n          }\n        }\n\n        // check filesystem\n        if (testRoute.check === true) {\n          const originalFsPathname = parsedUrlUpdated.pathname\n          const fsPathname = replaceBasePath(this.basePath, originalFsPathname!)\n\n          for (const fsRoute of this.fsRoutes) {\n            const fsParams = fsRoute.match(fsPathname)\n\n            if (fsParams) {\n              parsedUrlUpdated.pathname = fsPathname\n\n              const fsResult = await fsRoute.fn(\n                req,\n                res,\n                fsParams,\n                parsedUrlUpdated\n              )\n\n              if (fsResult.finished) {\n                return true\n              }\n\n              parsedUrlUpdated.pathname = originalFsPathname\n            }\n          }\n\n          let matchedPage = await memoizedPageChecker(fsPathname)\n\n          // If we didn't match a page check dynamic routes\n          if (!matchedPage) {\n            for (const dynamicRoute of this.dynamicRoutes) {\n              if (dynamicRoute.match(fsPathname)) {\n                matchedPage = true\n              }\n            }\n          }\n\n          // Matched a page or dynamic route so render it using catchAllRoute\n          if (matchedPage) {\n            parsedUrlUpdated.pathname = fsPathname\n\n            const pageParams = this.catchAllRoute.match(\n              parsedUrlUpdated.pathname\n            )\n\n            await this.catchAllRoute.fn(\n              req,\n              res,\n              pageParams as Params,\n              parsedUrlUpdated\n            )\n            return true\n          }\n        }\n      }\n    }\n\n    return false\n  }\n}\n"]}