{"version":3,"sources":["../../../../build/webpack/plugins/font-stylesheet-gathering-plugin.ts"],"names":["FontStylesheetGatheringPlugin","compiler","gatheredStylesheets","parserHandler","factory","JS_TYPES","type","hooks","parser","for","tap","constructor","name","evaluate","node","state","module","resource","includes","BasicEvaluatedExpression","setRange","range","setExpression","setIdentifier","undefined","call","arguments","length","isNodeCreatingLinkElement","propsNode","props","properties","forEach","prop","key","value","rel","href","OPTIMIZED_FONT_PROVIDERS","some","url","startsWith","push","apply","normalModuleFactory","make","tapAsync","compilation","cb","finishModules","_","modulesFinished","fontDefinitionPromises","map","manifestContent","promiseIndex","content","assets","RawSource","JSON","stringify","callee","componentNode"],"mappings":"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","sourcesContent":["// eslint-disable-next-line import/no-extraneous-dependencies\nimport { NodePath } from 'ast-types/lib/node-path'\nimport { compilation as CompilationType, Compiler } from 'webpack'\nimport { namedTypes } from 'ast-types'\nimport { RawSource } from 'webpack-sources'\nimport {\n  getFontDefinitionFromNetwork,\n  FontManifest,\n} from '../../../next-server/server/font-utils'\n// @ts-ignore\nimport BasicEvaluatedExpression from 'webpack/lib/BasicEvaluatedExpression'\nimport { OPTIMIZED_FONT_PROVIDERS } from '../../../next-server/lib/constants'\n\ninterface VisitorMap {\n  [key: string]: (path: NodePath) => void\n}\n\nexport class FontStylesheetGatheringPlugin {\n  compiler?: Compiler\n  gatheredStylesheets: Array<string> = []\n\n  private parserHandler = (\n    factory: CompilationType.NormalModuleFactory\n  ): void => {\n    const JS_TYPES = ['auto', 'esm', 'dynamic']\n    // Do an extra walk per module and add interested visitors to the walk.\n    for (const type of JS_TYPES) {\n      factory.hooks.parser\n        .for('javascript/' + type)\n        .tap(this.constructor.name, (parser: any) => {\n          /**\n           * Webpack fun facts:\n           * `parser.hooks.call.for` cannot catch calls for user defined identifiers like `__jsx`\n           * it can only detect calls for native objects like `window`, `this`, `eval` etc.\n           * In order to be able to catch calls of variables like `__jsx`, first we need to catch them as\n           * Identifier and then return `BasicEvaluatedExpression` whose `id` and `type` webpack matches to\n           * invoke hook for call.\n           * See: https://github.com/webpack/webpack/blob/webpack-4/lib/Parser.js#L1931-L1932.\n           */\n          parser.hooks.evaluate\n            .for('Identifier')\n            .tap(this.constructor.name, (node: namedTypes.Identifier) => {\n              // We will only optimize fonts from first party code.\n              if (parser?.state?.module?.resource.includes('node_modules')) {\n                return\n              }\n              return node.name === '__jsx'\n                ? new BasicEvaluatedExpression()\n                    //@ts-ignore\n                    .setRange(node.range)\n                    .setExpression(node)\n                    .setIdentifier('__jsx')\n                : undefined\n            })\n\n          parser.hooks.call\n            .for('__jsx')\n            .tap(this.constructor.name, (node: namedTypes.CallExpression) => {\n              if (node.arguments.length !== 2) {\n                // A font link tag has only two arguments rel=stylesheet and href='...'\n                return\n              }\n              if (!isNodeCreatingLinkElement(node)) {\n                return\n              }\n\n              // node.arguments[0] is the name of the tag and [1] are the props.\n              const propsNode = node.arguments[1] as namedTypes.ObjectExpression\n              const props: { [key: string]: string } = {}\n              propsNode.properties.forEach((prop) => {\n                if (prop.type !== 'Property') {\n                  return\n                }\n                if (\n                  prop.key.type === 'Identifier' &&\n                  prop.value.type === 'Literal'\n                ) {\n                  props[prop.key.name] = prop.value.value as string\n                }\n              })\n              if (\n                !props.rel ||\n                props.rel !== 'stylesheet' ||\n                !props.href ||\n                !OPTIMIZED_FONT_PROVIDERS.some((url) =>\n                  props.href.startsWith(url)\n                )\n              ) {\n                return false\n              }\n\n              this.gatheredStylesheets.push(props.href)\n            })\n        })\n    }\n  }\n\n  public apply(compiler: Compiler) {\n    this.compiler = compiler\n    compiler.hooks.normalModuleFactory.tap(\n      this.constructor.name,\n      this.parserHandler\n    )\n    compiler.hooks.make.tapAsync(this.constructor.name, (compilation, cb) => {\n      compilation.hooks.finishModules.tapAsync(\n        this.constructor.name,\n        async (_: any, modulesFinished: Function) => {\n          const fontDefinitionPromises = this.gatheredStylesheets.map((url) =>\n            getFontDefinitionFromNetwork(url)\n          )\n          let manifestContent: FontManifest = []\n\n          for (let promiseIndex in fontDefinitionPromises) {\n            manifestContent.push({\n              url: this.gatheredStylesheets[promiseIndex],\n              content: await fontDefinitionPromises[promiseIndex],\n            })\n          }\n          compilation.assets['font-manifest.json'] = new RawSource(\n            JSON.stringify(manifestContent, null, '  ')\n          )\n          modulesFinished()\n        }\n      )\n      cb()\n    })\n  }\n}\n\nfunction isNodeCreatingLinkElement(node: namedTypes.CallExpression) {\n  const callee = node.callee as namedTypes.Identifier\n  if (callee.type !== 'Identifier') {\n    return false\n  }\n  const componentNode = node.arguments[0] as namedTypes.Literal\n  if (componentNode.type !== 'Literal') {\n    return false\n  }\n  // Next has pragma: __jsx.\n  return callee.name === '__jsx' && componentNode.value === 'link'\n}\n"]}