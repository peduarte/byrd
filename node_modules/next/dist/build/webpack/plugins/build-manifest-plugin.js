"use strict";exports.__esModule=true;exports.default=void 0;var _devalue=_interopRequireDefault(require("next/dist/compiled/devalue"));var _webpackSources=require("webpack-sources");var _constants=require("../../../next-server/lib/constants");var _getRouteFromEntrypoint=_interopRequireDefault(require("../../../next-server/server/get-route-from-entrypoint"));var _nextDropClientPagePlugin=require("./next-drop-client-page-plugin");function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{default:obj};}// This function takes the asset map generated in BuildManifestPlugin and creates a
// reduced version to send to the client.
function generateClientManifest(assetMap,isModern){const clientManifest={};const appDependencies=new Set(assetMap.pages['/_app']);Object.entries(assetMap.pages).forEach(([page,dependencies])=>{if(page==='/_app')return;// Filter out dependencies in the _app entry, because those will have already
// been loaded by the client prior to a navigation event
const filteredDeps=dependencies.filter(dep=>!appDependencies.has(dep)&&(!dep.endsWith('.js')||dep.endsWith('.module.js')===isModern));// The manifest can omit the page if it has no requirements
if(filteredDeps.length){clientManifest[page]=filteredDeps;}});return(0,_devalue.default)(clientManifest);}function isJsFile(file){// We don't want to include `.hot-update.js` files into the initial page
return!file.endsWith('.hot-update.js')&&file.endsWith('.js');}// This plugin creates a build-manifest.json for all assets that are being output
// It has a mapping of "entry" filename to real filename. Because the real filename can be hashed in production
class BuildManifestPlugin{constructor(options){this.buildId=void 0;this.modern=void 0;this.buildId=options.buildId;this.modern=options.modern;}apply(compiler){compiler.hooks.emit.tapAsync('NextJsBuildManifest',(compilation,callback)=>{var _mainJsChunk$files$fi,_polyfillChunk$files$,_reactRefreshChunk$fi;const chunks=compilation.chunks;const assetMap={polyfillFiles:[],devFiles:[],ampDevFiles:[],lowPriorityFiles:[],pages:{'/_app':[]},ampFirstPages:[]};const ampFirstEntryNames=_nextDropClientPagePlugin.ampFirstEntryNamesMap.get(compilation);if(ampFirstEntryNames){for(const entryName of ampFirstEntryNames){const pagePath=(0,_getRouteFromEntrypoint.default)(entryName);if(!pagePath){continue;}assetMap.ampFirstPages.push(pagePath);}}const mainJsChunk=chunks.find(c=>c.name===_constants.CLIENT_STATIC_FILES_RUNTIME_MAIN);const mainJsFiles=(_mainJsChunk$files$fi=mainJsChunk===null||mainJsChunk===void 0?void 0:mainJsChunk.files.filter(isJsFile))!==null&&_mainJsChunk$files$fi!==void 0?_mainJsChunk$files$fi:[];const polyfillChunk=chunks.find(c=>c.name===_constants.CLIENT_STATIC_FILES_RUNTIME_POLYFILLS);// Create a separate entry  for polyfills
assetMap.polyfillFiles=(_polyfillChunk$files$=polyfillChunk===null||polyfillChunk===void 0?void 0:polyfillChunk.files.filter(isJsFile))!==null&&_polyfillChunk$files$!==void 0?_polyfillChunk$files$:[];const reactRefreshChunk=chunks.find(c=>c.name===_constants.CLIENT_STATIC_FILES_RUNTIME_REACT_REFRESH);assetMap.devFiles=(_reactRefreshChunk$fi=reactRefreshChunk===null||reactRefreshChunk===void 0?void 0:reactRefreshChunk.files.filter(isJsFile))!==null&&_reactRefreshChunk$fi!==void 0?_reactRefreshChunk$fi:[];for(const entrypoint of compilation.entrypoints.values()){const isAmpRuntime=entrypoint.name===_constants.CLIENT_STATIC_FILES_RUNTIME_AMP;if(isAmpRuntime){for(const file of entrypoint.getFiles()){if(!(isJsFile(file)||file.endsWith('.css'))){continue;}assetMap.ampDevFiles.push(file.replace(/\\/g,'/'));}continue;}const pagePath=(0,_getRouteFromEntrypoint.default)(entrypoint.name);if(!pagePath){continue;}const filesForEntry=[];// getFiles() - helper function to read the files for an entrypoint from stats object
for(const file of entrypoint.getFiles()){if(!(isJsFile(file)||file.endsWith('.css'))){continue;}filesForEntry.push(file.replace(/\\/g,'/'));}assetMap.pages[pagePath]=[...mainJsFiles,...filesForEntry];}// Add the runtime build manifest file (generated later in this file)
// as a dependency for the app. If the flag is false, the file won't be
// downloaded by the client.
assetMap.lowPriorityFiles.push(`${_constants.CLIENT_STATIC_FILES_PATH}/${this.buildId}/_buildManifest.js`);if(this.modern){assetMap.lowPriorityFiles.push(`${_constants.CLIENT_STATIC_FILES_PATH}/${this.buildId}/_buildManifest.module.js`);}// Add the runtime ssg manifest file as a lazy-loaded file dependency.
// We also stub this file out for development mode (when it is not
// generated).
const srcEmptySsgManifest=`self.__SSG_MANIFEST=new Set;self.__SSG_MANIFEST_CB&&self.__SSG_MANIFEST_CB()`;const ssgManifestPath=`${_constants.CLIENT_STATIC_FILES_PATH}/${this.buildId}/_ssgManifest.js`;assetMap.lowPriorityFiles.push(ssgManifestPath);compilation.assets[ssgManifestPath]=new _webpackSources.RawSource(srcEmptySsgManifest);if(this.modern){const ssgManifestPathModern=`${_constants.CLIENT_STATIC_FILES_PATH}/${this.buildId}/_ssgManifest.module.js`;assetMap.lowPriorityFiles.push(ssgManifestPathModern);compilation.assets[ssgManifestPathModern]=new _webpackSources.RawSource(srcEmptySsgManifest);}assetMap.pages=Object.keys(assetMap.pages).sort()// eslint-disable-next-line
.reduce((a,c)=>(a[c]=assetMap.pages[c],a),{});compilation.assets[_constants.BUILD_MANIFEST]=new _webpackSources.RawSource(JSON.stringify(assetMap,null,2));const clientManifestPath=`${_constants.CLIENT_STATIC_FILES_PATH}/${this.buildId}/_buildManifest.js`;compilation.assets[clientManifestPath]=new _webpackSources.RawSource(`self.__BUILD_MANIFEST = ${generateClientManifest(assetMap,false)};self.__BUILD_MANIFEST_CB && self.__BUILD_MANIFEST_CB()`);if(this.modern){const modernClientManifestPath=`${_constants.CLIENT_STATIC_FILES_PATH}/${this.buildId}/_buildManifest.module.js`;compilation.assets[modernClientManifestPath]=new _webpackSources.RawSource(`self.__BUILD_MANIFEST = ${generateClientManifest(assetMap,true)};self.__BUILD_MANIFEST_CB && self.__BUILD_MANIFEST_CB()`);}callback();});}}exports.default=BuildManifestPlugin;
//# sourceMappingURL=build-manifest-plugin.js.map